title: '设计模式学习-序'
date: 2014-06-23 11:35:10
categories:
	- 设计模式
	- java
tags:
	- 设计模式
	- java
---

学习面向对象已经很长时间了，刚开始是从学习C++语言的时候，知道面向对象这个名次，后来又学习了多种面向对象语言，c#，java等，大概在刚开始学习c#不久，在10年左右，就开始知道面向对象设计，可能是没有足够的代码量，一直敬而远之。虽然也经常在写代码时注意面向对象设计，甚至有时用得上一种设计模式就感觉比较有成就感。没有系统的学习思考过，如何做面向对象设计。本系列主要记录学习设计模式中的思考，以及一些示例，目前使用Java语言比较多，所以示例全部以Java为编程语言实现。
####What Design patterns
> 每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题解决方案的核心。这样你就能一次又一次地使用该方案而不必做重复劳动。

以上来自GOF的设计模式中引用的一句话，其实设计模式就是对一些常见问题的经验总结，有了这些经验我们可以减少复用我们的代码，减少我们的重复劳动。既然是经验总结，学习设计模式就需要了解What,Why,How(本篇只有What Design patterns，Why、How将在这结束时在总结)才能真正了解一种设计模式，本系列的学习也主要采用者几点的方式。

####Design patterns
以下列举了各种设计模式名字以及定义以及学习总结的地址。
Abstract Factory:提供一个创建一系列相关或相互依赖的接口，而无需指定它们具体的类。
Adapter：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本接口不兼容。而不能一起工作的类，可以一起工作。
Bridge：将抽象部分与它实现部分分类，使它们可以独立的变化。
Builder：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
Chain of Responsibility：为解除请求的发送者与接受者的耦合，而使多个对象都有机会处理这个请求，将这些对象连成链，并沿着链传递该请求直到有一个对象处理它。
Command：将一个清秀封装为一个对象，从而使你可用不同请求的客户进行参数化，对请求排队或者记录请求日志，以支持可取消操作。Composite：将对象组合成树形接口以表示“部分-整体”的层次结构。Composite使得客户对单个对象和复合对象的一致性。
Decorator：动态给对象增加一些额外的职责。
Facade：为子系统的一些接口提供一致的界面。
Factory Method：定义一个创建对象的接口，让子类来决定使用一个类来创建对象。
Flyweight：运用共享技术有效的支持大量细粒度的对象。
Interpreter：给定一个语言，定义它的文法的一种表示。并定义一个解释器，使用该解释器来解释语言中的句子。
Iterator：使用一个方法顺序的访问一个集合中的每一个元素，又不暴露该对象的内部表示。
Mediator：用一个中介对象来封装一系列的对象交互。
Memento：在不破坏封装的前提下捕捉一个对象的内部状态，并在对象之外保存这个状态。
Observer：定义对象之间的一种一对多的依赖关系，以便当一个对象发送改变时，所有依赖它的对象都得到通知并自动更新。
Prototype：用原型实例指定创建对象的种类，并通过拷贝这个原型来创建新的对象。
Proxy：为其他对象提供一个代理以控制这个对象的访问。
Singleton：保证一个类仅有一个实例，并且提供它的全局访问点。
State：允许一个对象在其内部状态改变时改变它的行为。
Strategy：定义一系列软法，把他们一个个封装起来，并且使他们可相互替换。
Template Method：定义操作中的算法骨架，将这些子类延迟到子类中。
Visitor：表示一个作用于某个对象结构中的各个元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。
####Source
学习中示例代码：
https://github.com/wangyan9110/Designpatterns.git
####Reference
设计模式--可复用面向对象软件的基础
大话设计模式
